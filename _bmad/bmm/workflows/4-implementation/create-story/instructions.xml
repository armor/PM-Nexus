<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and generate all documents in {document_output_language}</critical>

  <critical>üî• CRITICAL MISSION: You are creating the ULTIMATE story context engine that prevents LLM developer mistakes, omissions or
    disasters! üî•</critical>
  <critical>Your purpose is NOT to copy from epics - it's to create a comprehensive, optimized story file that gives the DEV agent
    EVERYTHING needed for flawless implementation</critical>
  <critical>COMMON LLM MISTAKES TO PREVENT: reinventing wheels, wrong libraries, wrong file locations, breaking regressions, ignoring UX,
    vague implementations, lying about completion, not learning from past work</critical>
  <critical>üö® EXHAUSTIVE ANALYSIS REQUIRED: You must thoroughly analyze ALL artifacts to extract critical context - do NOT be lazy or skim!
    This is the most important function in the entire development process!</critical>
  <critical>üî¨ UTILIZE SUBPROCESSES AND SUBAGENTS: Use research subagents, subprocesses or parallel processing if available to thoroughly
    analyze different artifacts simultaneously and thoroughly</critical>
  <critical>‚ùì SAVE QUESTIONS: If you think of questions or clarifications during analysis, save them for the end after the complete story is
    written</critical>
  <critical>üéØ ZERO USER INTERVENTION: Process should be fully automated except for initial epic/story selection or missing documents</critical>

  <step n="1" goal="Determine target story">
    <check if="{{story_path}} is provided by user or user provided the epic and story number such as 2-4 or 1.6 or epic 1 story 5">
      <action>Parse user-provided story path: extract epic_num, story_num, story_title from format like "1-2-user-auth"</action>
      <action>Set {{epic_num}}, {{story_num}}, {{story_key}} from user input</action>
      <action>GOTO step 2a</action>
    </check>

    <action>Check if {{sprint_status}} file exists for auto discover</action>
    <check if="sprint status file does NOT exist">
      <output>üö´ No sprint status file found and no story specified</output>
      <output>
        **Required Options:**
        1. Run `sprint-planning` to initialize sprint tracking (recommended)
        2. Provide specific epic-story number to create (e.g., "1-2-user-auth")
        3. Provide path to story documents if sprint status doesn't exist yet
      </output>
      <ask>Choose option [1], provide epic-story number, path to story docs, or [q] to quit:</ask>

      <check if="user chooses 'q'">
        <action>HALT - No work needed</action>
      </check>

      <check if="user chooses '1'">
        <output>Run sprint-planning workflow first to create sprint-status.yaml</output>
        <action>HALT - User needs to run sprint-planning</action>
      </check>

      <check if="user provides epic-story number">
        <action>Parse user input: extract epic_num, story_num, story_title</action>
        <action>Set {{epic_num}}, {{story_num}}, {{story_key}} from user input</action>
        <action>GOTO step 2a</action>
      </check>

      <check if="user provides story docs path">
        <action>Use user-provided path for story documents</action>
        <action>GOTO step 2a</action>
      </check>
    </check>

    <!-- Auto-discover from sprint status only if no user input -->
    <check if="no user input provided">
      <critical>MUST read COMPLETE {sprint_status} file from start to end to preserve order</critical>
      <action>Load the FULL file: {{sprint_status}}</action>
      <action>Read ALL lines from beginning to end - do not skip any content</action>
      <action>Parse the development_status section completely</action>

      <action>Find the FIRST story (by reading in order from top to bottom) where:
        - Key matches pattern: number-number-name (e.g., "1-2-user-auth")
        - NOT an epic key (epic-X) or retrospective (epic-X-retrospective)
        - Status value equals "backlog"
      </action>

      <check if="no backlog story found">
        <output>üìã No backlog stories found in sprint-status.yaml

          All stories are either already created, in progress, or done.

          **Options:**
          1. Run sprint-planning to refresh story tracking
          2. Load PM agent and run correct-course to add more stories
          3. Check if current sprint is complete and run retrospective
        </output>
        <action>HALT</action>
      </check>

      <action>Extract from found story key (e.g., "1-2-user-authentication"):
        - epic_num: first number before dash (e.g., "1")
        - story_num: second number after first dash (e.g., "2")
        - story_title: remainder after second dash (e.g., "user-authentication")
      </action>
      <action>Set {{story_id}} = "{{epic_num}}.{{story_num}}"</action>
      <action>Store story_key for later use (e.g., "1-2-user-authentication")</action>

      <!-- Mark epic as in-progress if this is first story -->
      <action>Check if this is the first story in epic {{epic_num}} by looking for {{epic_num}}-1-* pattern</action>
      <check if="this is first story in epic {{epic_num}}">
        <action>Load {{sprint_status}} and check epic-{{epic_num}} status</action>
        <action>If epic status is "backlog" ‚Üí update to "in-progress"</action>
        <action>If epic status is "contexted" (legacy status) ‚Üí update to "in-progress" (backward compatibility)</action>
        <action>If epic status is "in-progress" ‚Üí no change needed</action>
        <check if="epic status is 'done'">
          <output>üö´ ERROR: Cannot create story in completed epic</output>
          <output>Epic {{epic_num}} is marked as 'done'. All stories are complete.</output>
          <output>If you need to add more work, either:</output>
          <output>1. Manually change epic status back to 'in-progress' in sprint-status.yaml</output>
          <output>2. Create a new epic for additional work</output>
          <action>HALT - Cannot proceed</action>
        </check>
        <check if="epic status is not one of: backlog, contexted, in-progress, done">
          <output>üö´ ERROR: Invalid epic status '{{epic_status}}'</output>
          <output>Epic {{epic_num}} has invalid status. Expected: backlog, in-progress, or done</output>
          <output>Please fix sprint-status.yaml manually or run sprint-planning to regenerate</output>
          <action>HALT - Cannot proceed</action>
        </check>
        <output>üìä Epic {{epic_num}} status updated to in-progress</output>
      </check>

      <action>GOTO step 2a</action>
    </check>
    <action>Load the FULL file: {{sprint_status}}</action>
    <action>Read ALL lines from beginning to end - do not skip any content</action>
    <action>Parse the development_status section completely</action>

    <action>Find the FIRST story (by reading in order from top to bottom) where:
      - Key matches pattern: number-number-name (e.g., "1-2-user-auth")
      - NOT an epic key (epic-X) or retrospective (epic-X-retrospective)
      - Status value equals "backlog"
    </action>

    <check if="no backlog story found">
      <output>üìã No backlog stories found in sprint-status.yaml

        All stories are either already created, in progress, or done.

        **Options:**
        1. Run sprint-planning to refresh story tracking
        2. Load PM agent and run correct-course to add more stories
        3. Check if current sprint is complete and run retrospective
      </output>
      <action>HALT</action>
    </check>

    <action>Extract from found story key (e.g., "1-2-user-authentication"):
      - epic_num: first number before dash (e.g., "1")
      - story_num: second number after first dash (e.g., "2")
      - story_title: remainder after second dash (e.g., "user-authentication")
    </action>
    <action>Set {{story_id}} = "{{epic_num}}.{{story_num}}"</action>
    <action>Store story_key for later use (e.g., "1-2-user-authentication")</action>

    <!-- Mark epic as in-progress if this is first story -->
    <action>Check if this is the first story in epic {{epic_num}} by looking for {{epic_num}}-1-* pattern</action>
    <check if="this is first story in epic {{epic_num}}">
      <action>Load {{sprint_status}} and check epic-{{epic_num}} status</action>
      <action>If epic status is "backlog" ‚Üí update to "in-progress"</action>
      <action>If epic status is "contexted" (legacy status) ‚Üí update to "in-progress" (backward compatibility)</action>
      <action>If epic status is "in-progress" ‚Üí no change needed</action>
      <check if="epic status is 'done'">
        <output>üö´ ERROR: Cannot create story in completed epic</output>
        <output>Epic {{epic_num}} is marked as 'done'. All stories are complete.</output>
        <output>If you need to add more work, either:</output>
        <output>1. Manually change epic status back to 'in-progress' in sprint-status.yaml</output>
        <output>2. Create a new epic for additional work</output>
        <action>HALT - Cannot proceed</action>
      </check>
      <check if="epic status is not one of: backlog, contexted, in-progress, done">
        <output>üö´ ERROR: Invalid epic status '{{epic_status}}'</output>
        <output>Epic {{epic_num}} has invalid status. Expected: backlog, in-progress, or done</output>
        <output>Please fix sprint-status.yaml manually or run sprint-planning to regenerate</output>
        <action>HALT - Cannot proceed</action>
      </check>
      <output>üìä Epic {{epic_num}} status updated to in-progress</output>
    </check>

    <action>GOTO step 2a</action>
  </step>

  <step n="2" goal="Load and analyze core artifacts">
    <critical>üî¨ EXHAUSTIVE ARTIFACT ANALYSIS - This is where you prevent future developer fuckups!</critical>

    <!-- Load all available content through discovery protocol -->
    <invoke-protocol
      name="discover_inputs" />
    <note>Available content: {epics_content}, {prd_content}, {architecture_content}, {ux_content},
    {project_context}</note>

    <!-- Analyze epics file for story foundation -->
    <action>From {epics_content}, extract Epic {{epic_num}} complete context:</action> **EPIC ANALYSIS:** - Epic
    objectives and business value - ALL stories in this epic for cross-story context - Our specific story's requirements, user story
    statement, acceptance criteria - Technical requirements and constraints - Dependencies on other stories/epics - Source hints pointing to
    original documents <!-- Extract specific story requirements -->
    <action>Extract our story ({{epic_num}}-{{story_num}}) details:</action> **STORY FOUNDATION:** - User story statement
    (As a, I want, so that) - Detailed acceptance criteria (already BDD formatted) - Technical requirements specific to this story -
    Business context and value - Success criteria <!-- Previous story analysis for context continuity -->
    <check if="story_num > 1">
      <action>Load previous story file: {{story_dir}}/{{epic_num}}-{{previous_story_num}}-*.md</action> **PREVIOUS STORY INTELLIGENCE:** -
    Dev notes and learnings from previous story - Review feedback and corrections needed - Files that were created/modified and their
    patterns - Testing approaches that worked/didn't work - Problems encountered and solutions found - Code patterns established <action>Extract
    all learnings that could impact current story implementation</action>
    </check>

    <!-- Git intelligence for previous work patterns -->
    <check
      if="previous story exists AND git repository detected">
      <action>Get last 5 commit titles to understand recent work patterns</action>
      <action>Analyze 1-5 most recent commits for relevance to current story:
        - Files created/modified
        - Code patterns and conventions used
        - Library dependencies added/changed
        - Architecture decisions implemented
        - Testing approaches used
      </action>
      <action>Extract actionable insights for current story implementation</action>
    </check>
  </step>

  <step n="3" goal="Architecture analysis for developer guardrails">
    <critical>üèóÔ∏è ARCHITECTURE INTELLIGENCE - Extract everything the developer MUST follow!</critical> **ARCHITECTURE DOCUMENT ANALYSIS:** <action>Systematically
    analyze architecture content for story-relevant requirements:</action>

    <!-- Load architecture - single file or sharded -->
    <check if="architecture file is single file">
      <action>Load complete {architecture_content}</action>
    </check>
    <check if="architecture is sharded to folder">
      <action>Load architecture index and scan all architecture files</action>
    </check> **CRITICAL ARCHITECTURE EXTRACTION:** <action>For
    each architecture section, determine if relevant to this story:</action> - **Technical Stack:** Languages, frameworks, libraries with
    versions - **Code Structure:** Folder organization, naming conventions, file patterns - **API Patterns:** Service structure, endpoint
    patterns, data contracts - **Database Schemas:** Tables, relationships, constraints relevant to story - **Security Requirements:**
    Authentication patterns, authorization rules - **Performance Requirements:** Caching strategies, optimization patterns - **Testing
    Standards:** Testing frameworks, coverage expectations, test patterns - **Deployment Patterns:** Environment configurations, build
    processes - **Integration Patterns:** External service integrations, data flows <action>Extract any story-specific requirements that the
    developer MUST follow</action>
    <action>Identify any architectural decisions that override previous patterns</action>
  </step>

  <step n="4" goal="Web research for latest technical specifics">
    <critical>üåê ENSURE LATEST TECH KNOWLEDGE - Prevent outdated implementations!</critical> **WEB INTELLIGENCE:** <action>Identify specific
    technical areas that require latest version knowledge:</action>

    <!-- Check for libraries/frameworks mentioned in architecture -->
    <action>From architecture analysis, identify specific libraries, APIs, or
    frameworks</action>
    <action>For each critical technology, research latest stable version and key changes:
      - Latest API documentation and breaking changes
      - Security vulnerabilities or updates
      - Performance improvements or deprecations
      - Best practices for current version
    </action>
    **EXTERNAL CONTEXT INCLUSION:** <action>Include in story any critical latest information the developer needs:
      - Specific library versions and why chosen
      - API endpoints with parameters and authentication
      - Recent security patches or considerations
      - Performance optimization techniques
      - Migration considerations if upgrading
    </action>
  </step>

  <step n="4b" goal="Create Tasks and Subtasks for JIRA hierarchy">
    <critical>üìã JIRA HIERARCHY: Stories sync as Epic ‚Üí Story ‚Üí Task ‚Üí Sub-task</critical>
    <critical>Each story MUST have well-defined Tasks with atomic Subtasks</critical>

    <action>For each Acceptance Criterion (AC-N), create ONE Task:</action>
    <rule>Task naming: {{story_key}}-T1, {{story_key}}-T2, etc.</rule>
    <rule>Task title: Clear, actionable description matching the AC</rule>
    <rule>Linked to: Reference the AC number (AC-1, AC-2, etc.)</rule>

    <action>For each Task, create 2-5 atomic Subtasks:</action>
    <rule>Subtask naming: T1-S1, T1-S2, etc.</rule>
    <rule>Subtasks should be small, completable in 1-2 hours max</rule>
    <rule>Common subtask patterns:
      - S1: Core implementation
      - S2: Write unit tests
      - S3: Integration test
      - S4: Documentation update
    </rule>

    <action>Always include a final "Verification & Documentation" task with subtasks:</action>
    <example>
      ### {{story_key}}-T{{n}}: Verification &amp; Documentation
      | Subtask | Description | Status |
      |---------|-------------|--------|
      | T{{n}}-S1 | Run all unit tests | pending |
      | T{{n}}-S2 | Run integration tests | pending |
      | T{{n}}-S3 | Code review prep | pending |
      | T{{n}}-S4 | Update documentation | pending |
    </example>

    <critical>Task count guidance:
      - 1-2 point story: 2-3 tasks
      - 3-5 point story: 3-5 tasks
      - 8+ point story: 5-8 tasks (consider splitting story)
    </critical>
  </step>

  <step n="5" goal="Create comprehensive story file">
    <critical>üìù CREATE ULTIMATE STORY FILE - The developer's master implementation guide!</critical>

    <action>Initialize from template.md:
    {default_output_file}</action>
    <template-output file="{default_output_file}">story_header</template-output>

    <!-- Story foundation from epics analysis -->
    <template-output
      file="{default_output_file}">story_requirements</template-output>

    <!-- Tasks and Subtasks for JIRA hierarchy -->
    <template-output file="{default_output_file}">tasks_and_subtasks</template-output>

    <!-- Developer context section - MOST IMPORTANT PART -->
    <template-output file="{default_output_file}">
    developer_context_section</template-output> **DEV AGENT GUARDRAILS:** <template-output file="{default_output_file}">
    technical_requirements</template-output>
    <template-output file="{default_output_file}">architecture_compliance</template-output>
    <template-output
      file="{default_output_file}">library_framework_requirements</template-output>
    <template-output file="{default_output_file}">
    file_structure_requirements</template-output>
    <template-output file="{default_output_file}">testing_requirements</template-output>

    <!-- Previous story intelligence -->
    <check
      if="previous story learnings available">
      <template-output file="{default_output_file}">previous_story_intelligence</template-output>
    </check>

    <!-- Git intelligence -->
    <check
      if="git analysis completed">
      <template-output file="{default_output_file}">git_intelligence_summary</template-output>
    </check>

    <!-- Latest technical specifics -->
    <check if="web research completed">
      <template-output file="{default_output_file}">latest_tech_information</template-output>
    </check>

    <!-- Project context reference -->
    <template-output
      file="{default_output_file}">project_context_reference</template-output>

    <!-- Final status update -->
    <template-output file="{default_output_file}">
    story_completion_status</template-output>

    <!-- CRITICAL: Set status to ready-for-dev -->
    <action>Set story Status to: "ready-for-dev"</action>
    <action>Add completion note: "Ultimate
    context engine analysis completed - comprehensive developer guide created"</action>
  </step>

  <step n="6" goal="Update sprint status and finalize">
    <invoke-task>Validate against checklist at {installed_path}/checklist.md using _bmad/core/tasks/validate-workflow.xml</invoke-task>
    <action>Save story document unconditionally</action>

    <!-- Update sprint status -->
    <check if="sprint status file exists">
      <action>Update {{sprint_status}}</action>
      <action>Load the FULL file and read all development_status entries</action>
      <action>Find development_status key matching {{story_key}}</action>
      <action>Verify current status is "backlog" (expected previous state)</action>
      <action>Update development_status[{{story_key}}] = "ready-for-dev"</action>
      <action>Save file, preserving ALL comments and structure including STATUS DEFINITIONS</action>
    </check>
  </step>

  <step n="7" goal="Create git worktree with epic branch coordination">
    <critical>WORKTREE + EPIC BRANCH SETUP - Enable multi-developer parallel story execution</critical>
    <critical>Stories branch from EPIC BRANCH (not main) for early conflict detection</critical>

    <!-- Reference worktree-setup task -->
    <invoke-task>Create worktree using {project-root}/_bmad/core/tasks/worktree-setup.xml</invoke-task>

    <action>Verify git repository exists in project root</action>
    <check if="git repository exists">
      <!-- Prepare branch names -->
      <action>Set {{branch_name}} = "story/{{story_key}}"</action>
      <action>Set {{worktree_path}} = "{{project_root}}/.worktrees/{{story_key}}"</action>

      <!-- Determine epic branch name -->
      <action>Try to extract epic_name from epics.md if available</action>
      <check if="epic_name available">
        <action>Set {{epic_branch}} = "epic/{{epic_num}}-{{epic_name}}"</action>
      </check>
      <check if="epic_name NOT available">
        <action>Set {{epic_branch}} = "epic/{{epic_num}}"</action>
      </check>

      <!-- Fetch latest from remote -->
      <action>Run: `git fetch origin`</action>

      <!-- Step 7a: Ensure epic branch exists (critical for multi-developer flow) -->
      <action>Check if epic branch exists locally: `git branch --list {{epic_branch}}`</action>
      <action>Check if epic branch exists on remote: `git ls-remote --heads origin {{epic_branch}}`</action>

      <check if="epic_branch exists locally">
        <action>Update epic branch: `git checkout {{epic_branch}} && git pull origin {{epic_branch}} && git checkout -`</action>
        <action>Set {{epic_branch_created}} = false</action>
        <output>Using existing epic branch: {{epic_branch}}</output>
      </check>

      <check if="epic_branch exists on remote but NOT locally">
        <action>Create local tracking branch: `git checkout -b {{epic_branch}} origin/{{epic_branch}} && git checkout -`</action>
        <action>Set {{epic_branch_created}} = false</action>
        <output>Tracking remote epic branch: {{epic_branch}}</output>
      </check>

      <check if="epic_branch does NOT exist anywhere">
        <critical>First story in epic - create epic integration branch from main</critical>
        <action>Ensure main is up to date: `git checkout main && git pull origin main`</action>
        <action>Create epic branch from main: `git checkout -b {{epic_branch}}`</action>
        <action>Push epic branch to remote: `git push -u origin {{epic_branch}}`</action>
        <action>Return to previous branch: `git checkout -`</action>
        <action>Set {{epic_branch_created}} = true</action>
        <output>
**Created new epic branch: {{epic_branch}}**
This is the first story in Epic {{epic_num}}.
All stories in this epic will branch from and merge to {{epic_branch}}.
        </output>
      </check>

      <!-- Step 7b: Create worktree branching from EPIC branch (not main) -->
      <action>Run: `git worktree list | grep {{worktree_path}}`</action>

      <check if="worktree already exists">
        <output>Worktree already exists for {{story_key}} - reusing existing</output>
        <action>Set {{worktree_created}} = true</action>
      </check>

      <check if="worktree does NOT exist">
        <!-- Create .worktrees directory if needed -->
        <action>Run: `mkdir -p {{project_root}}/.worktrees`</action>

        <!-- Check if story branch exists -->
        <action>Run: `git branch --list {{branch_name}}`</action>

        <check if="branch exists">
          <action>Run: `git worktree add {{worktree_path}} {{branch_name}}`</action>
        </check>

        <check if="branch does NOT exist">
          <!-- Create new branch from EPIC BRANCH (not main) and worktree together -->
          <action>Run: `git worktree add -b {{branch_name}} {{worktree_path}} {{epic_branch}}`</action>
        </check>

        <check if="worktree creation succeeds">
          <action>Set {{worktree_created}} = true</action>
          <output>Worktree created: {{worktree_path}} (branched from {{epic_branch}})</output>
        </check>

        <check if="worktree creation fails">
          <output>WARNING: Failed to create worktree - development will proceed in main directory</output>
          <action>Set {{worktree_created}} = false</action>
        </check>
      </check>

      <!-- Update sprint status with worktree AND epic branch info -->
      <check if="sprint status file exists AND worktree_created">
        <action>Add worktree and epic metadata to story entry in sprint-status.yaml:
          worktree_path: {{worktree_path}}
          branch_name: {{branch_name}}
          epic_branch: {{epic_branch}}
          created_at: {{timestamp}}
        </action>
        <action>Update epic entry with:
          epic_branch: {{epic_branch}}
          active_stories: [add {{branch_name}} to list]
        </action>
      </check>

      <!-- Ensure .worktrees is gitignored -->
      <action>Check if .worktrees is in .gitignore</action>
      <check if=".worktrees not in .gitignore">
        <action>Append ".worktrees/" to .gitignore</action>
      </check>
    </check>

    <check if="git repository does NOT exist">
      <output>No git repository found - skipping worktree setup</output>
      <action>Set {{worktree_created}} = false</action>
    </check>

    <action>Report completion</action>
    <output>**ULTIMATE BMad Method STORY CONTEXT CREATED, {user_name}!**

      **Story Details:**
      - Story ID: {{story_id}}
      - Story Key: {{story_key}}
      - File: {{story_file}}
      - Status: ready-for-dev

      **Parallel Development Setup:**
      {{#if worktree_created}}
      - Story Branch: {{branch_name}}
      - Epic Branch: {{epic_branch}}
      - Worktree: {{worktree_path}}
      {{#if epic_branch_created}}
      - NOTE: Created new epic branch (first story in Epic {{epic_num}})
      {{/if}}

      **Branch Hierarchy:**
      ```
      main
      ‚îî‚îÄ‚îÄ {{epic_branch}}
          ‚îî‚îÄ‚îÄ {{branch_name}} ‚Üê YOU ARE HERE
      ```
      {{else}}
      - Worktree: Not created (development in main directory)
      {{/if}}

      **Multi-Developer Workflow:**
      1. Other devs on same epic also branch from {{epic_branch}}
      2. Completed stories merge to {{epic_branch}} (not main)
      3. Conflicts with other epic stories detected early
      4. Epic merges to main when all stories complete

      **Next Steps:**
      1. Review the comprehensive story in {{story_file}}
      {{#if worktree_created}}
      2. Run `dev-story` (will use worktree at {{worktree_path}})
      {{else}}
      2. Run `dev-story` for implementation
      {{/if}}
      3. Run `code-review` when complete
      4. Run `security-review` after code-review passes
      5. Run `party-review` for Review Board approval (final gate)
      6. After all reviews pass, run `worktree-cleanup` to merge to {{epic_branch}}
      7. When ALL epic stories complete, run `epic-cleanup` to merge to main

      **The developer now has everything needed for flawless implementation!**
    </output>
  </step>

</workflow>